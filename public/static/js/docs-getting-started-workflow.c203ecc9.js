(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{"./components/Hint.jsx":function(e,n,t){"use strict";var o=t("./node_modules/react/index.js"),a=t.n(o);function r(){var e=function(e,n){n||(n=e.slice(0));return Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(n)}}))}(["\n  margin: 2rem 0;\n  padding: 1rem;\n  background-color: ",";\n  border: 0;\n  border-style: solid;\n  border-color: rgb(56, 132, 255);\n  border-left-width: 3px;\n  border-radius: 3px;\n"]);return r=function(){return e},e}var i=t("./node_modules/styled-components/dist/styled-components.browser.esm.js").a.div(r(),function(e){switch(e.variant){case"success":return"rgb(245, 247, 249)";default:return"rgb(245, 247, 249);"}}),m=function(e){var n=e.variant,t=e.children;return a.a.createElement(i,{variant:n},t)};n.a=m,m.__docgenInfo={description:"",methods:[],displayName:"Hint"}},"./docs/getting-started/workflow.mdx":function(e,n,t){"use strict";t.r(n),t.d(n,"default",function(){return u});var o=t("./node_modules/react/index.js"),a=t.n(o),r=t("./node_modules/@mdx-js/tag/dist/index.js"),i=t("./components/Hint.jsx");function m(e){return(m="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}function p(e,n){for(var t=0;t<n.length;t++){var o=n[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,o.key,o)}}function c(e,n){return!n||"object"!==m(n)&&"function"!==typeof n?function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}(e):n}function l(e){return(l=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function d(e,n){return(d=Object.setPrototypeOf||function(e,n){return e.__proto__=n,e})(e,n)}var u=function(e){function n(e){var t;return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),(t=c(this,l(n).call(this,e))).layout=null,t}var t,o,m;return function(e,n){if("function"!==typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),n&&d(e,n)}(n,a.a.Component),t=n,(o=[{key:"render",value:function(){var e=this.props,n=e.components;s(e,["components"]);return a.a.createElement(r.MDXTag,{name:"wrapper",components:n},a.a.createElement(r.MDXTag,{name:"h1",components:n,props:{id:"workflow"}},"Workflow"),a.a.createElement(r.MDXTag,{name:"p",components:n},"Atomic layout is based on CSS Grid. Please make yourself comfortable at that topic to eliminate most of the questions and make your experience superb. You don't have to be an expert, but having a basic knowledge on how CSS Grid works will help you to get more from Atomic layout."),a.a.createElement(i.a,null,"We recommend reading through the"," ",a.a.createElement("a",{href:"https://css-tricks.com/snippets/css/complete-guide-grid"},"Complete guide to Grid"),"."),a.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"declarative-ui"}},"Declarative UI"),a.a.createElement(r.MDXTag,{name:"p",components:n},"The biggest difference when working with Atomic layout is that you declare what your layout suppose to look like, without explicitly telling how that must be achieved."),a.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"creating-a-composition"}},"Creating a composition"),a.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"import"}},"Import"),a.a.createElement(r.MDXTag,{name:"p",components:n},"Start from importing a ",a.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Composition")," component from the ",a.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"atomic-layout")," package:"),a.a.createElement(r.MDXTag,{name:"pre",components:n},a.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx"}},"// ES6+\nimport { Composition } from 'atomic-layout'\n\n// CommonJS\nconst Composition = require('atomic-layout').Composition\n")),a.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"define-layout-areas"}},"Define layout areas"),a.a.createElement(r.MDXTag,{name:"p",components:n},"The next step is to think of what layout areas current composition acquires."),a.a.createElement(r.MDXTag,{name:"pre",components:n},a.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx"}},"import React from 'react'\nimport { Composition } from 'atomic-layout'\n\n// grid areas on mobile devices\nconst templateMobile = `\n  header\n  content\n  footer\n`\n\n// grid areas on tablets\nconst templateTablet = `\n  header header\n  content aside\n  footer footer\n`\n")),a.a.createElement(i.a,null,"Use ",a.a.createElement("code",null,"grid-template-areas")," syntax when declaring grid areas. Notice the explicit single quotes wrapping each line."),a.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"configure-composition"}},"Configure ",a.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"h3"},"Composition")),a.a.createElement(r.MDXTag,{name:"p",components:n},"Areas declaration alone will not do anything, we need to pass those areas as a value of the ",a.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"template")," prop of our ",a.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Composition")," component:"),a.a.createElement(r.MDXTag,{name:"pre",components:n},a.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx"}},"import React from 'react'\nimport { Composition } from 'atomic-layout'\n\n// grid areas on mobile devices\nconst templateMobile = `\n  header\n  content\n  footer\n`\n\n// grid areas on tablets\nconst templateTablet = `\n  header header\n  content aside\n  footer footer\n`\n\nconst Page = () => (\n  <Composition\n    template={templateMobile}\n    templateMd={templateTablet}>\n    {() => (/* See next step */)}\n  </Composition>\n)\n\nexport default Page\n")),a.a.createElement(r.MDXTag,{name:"p",components:n},"Notice how we appended an ",a.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"md")," suffix in ",a.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"templateMd"),". ",a.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"md")," there refers to a breakpoint name, and having it as a suffix if any prop giving to ",a.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Composition")," tells it to apply the value at that breakpoint. That is a feature called ",a.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"../../fundamentals/responsive-props.md"}},"Responsive props"),"."),a.a.createElement(r.MDXTag,{name:"h3",components:n,props:{id:"render-layout-areas"}},"Render layout areas"),a.a.createElement(r.MDXTag,{name:"p",components:n},a.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Composition")," component expects a function as its children. That function exposes areas components based on the given ",a.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"template")," values."),a.a.createElement(r.MDXTag,{name:"pre",components:n},a.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-jsx"}},"import React from 'react'\nimport { Composition } from 'atomic-layout'\n\n// grid areas on mobile devices\nconst templateMobile = `\n  header\n  content\n  footer\n`\n\n// grid areas on tablets\nconst templateTablet = `\n  header header\n  content aside\n  footer footer\n`\n\nconst Page = () => (\n  <Composition template={templateMobile} templateMd={templateTablet}>\n    {({ Header, Content, Aside, Footer }) => (\n      <>\n        <Header>Header</Header>\n        <Content>Content</Content>\n        <Aside>Aside</Aside>\n        <Footer>Footer</Footer>\n      </>\n    )}\n  </Composition>\n)\n\nexport default Page\n")),a.a.createElement(i.a,null,"Notice that the Aside area exists only in templateTablet declaration. Atomic layout will automatically wrap it in a proper `",a.a.createElement(MediaQuery,null),"` component to prevent it from rendering on mobile devices. **Responsive grid areas are built-in**."),a.a.createElement(r.MDXTag,{name:"p",components:n},"That's it. We have created a layout composition for our ",a.a.createElement(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Page")," component, that consist of four layout areas. No we can render another compositions inside those layout areas, thus making a ",a.a.createElement(r.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"../../components/composition.md#nested-composition"}},"Nested composition"),". The latter is a main distinctive key of Atomic layout, which allows to create immersive layouts following the same pattern."))}}])&&p(t.prototype,o),m&&p(t,m),n}();u.__docgenInfo={description:"",methods:[],displayName:"MDXContent"}}}]);
//# sourceMappingURL=docs-getting-started-workflow.5fd4b2fe77f74c6e4639.js.map